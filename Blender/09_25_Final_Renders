import bpy
import os
import math
import mathutils

# === USER SETTINGS ===
# Try multiple common locations to find files
POSSIBLE_LOCATIONS = [
    "/Users/styagi/Downloads",
    "/Users/styagi/Desktop",
    "/Users/styagi/Desktop/3D Bag Fitting",
    "/Users/styagi@christiandior.com/Desktop/3D Bag Fitting",
    os.path.expanduser("~/Downloads"),
    os.path.expanduser("~/Desktop")
]

BAG_FILE = "toujours.glb"

# Updated target offsets - shifted AirPods more left and CardHolder more right
ITEM_FILES = {
    "Pouch":      ("pink caro card holder.glb",     13/1500, mathutils.Vector(( 0.35,  0.10, -0.58))),      # Right side (unchanged)
    "CardHolder": ("pink lady dior wallet.glb",     250/600, mathutils.Vector((-0.05,  0.15, -0.10))),      # More right (-0.15 â†’ -0.05)
    "PhoneCase":  ("Caro portfeuille.glb",          55/6,    mathutils.Vector(( 0.15, -0.10, -0.15))),      # Right side (unchanged)
    "AirPods":    ("airpods_max.glb",               6.5/100, mathutils.Vector((-0.28, -0.10, -0.15)))       # More left (-0.15 â†’ -0.25)
}

# Bag scale
BAG_SCALE = 1.4

# Animation settings
START_FRAME = 1
DURATION = 40
GAP = 10
RADIUS = 0.6
HEIGHT = 1.0
ADDITIONAL_CARD_HOLDER_OFFSET = mathutils.Vector((0, 0, 0.05))
HANDLE_ROTATION_AMOUNT = math.radians(5)
HANDLE_ROTATION_AXIS = mathutils.Vector((1, 0, 0))

# === MATERIAL FUNCTIONS ===
def set_bag_transparency(bag_object, alpha_value=0.2):
    """Set transparency for the bag. Alpha 0.2 = 80% transparency"""
    if not bag_object:
        return False
        
    # For each material in the bag
    for slot in bag_object.material_slots:
        if not slot.material:
            continue
            
        mat = slot.material
        
        # Set material to use nodes
        mat.use_nodes = True
        nodes = mat.node_tree.nodes
        
        # Check if material already has a principled BSDF shader
        principled = None
        for node in nodes:
            if node.type == 'BSDF_PRINCIPLED':
                principled = node
                break
                
        # If no principled shader found, create one
        if not principled:
            principled = nodes.new(type='ShaderNodeBsdPrincipled')
            
        # Set material properties
        principled.inputs["Alpha"].default_value = alpha_value
        
        # Make sure material uses blend mode
        mat.blend_method = 'BLEND'
        
    return True


def animate_bag_transparency(bag_object, start_frame, duration, start_alpha=1.0, end_alpha=0.2):
    """Animate the bag transparency from opaque to transparent"""
    if not bag_object:
        return False
    
    # For each material in the bag
    for slot in bag_object.material_slots:
        if not slot.material:
            continue
            
        mat = slot.material
        
        # Set material to use nodes
        mat.use_nodes = True
        nodes = mat.node_tree.nodes
        
        # Check if material already has a principled BSDF shader
        principled = None
        for node in nodes:
            if node.type == 'BSDF_PRINCIPLED':
                principled = node
                break
                
        # If no principled shader found, create one
        if not principled:
            principled = nodes.new(type='ShaderNodeBsdPrincipled')
            
        # Set initial transparency
        principled.inputs["Alpha"].default_value = start_alpha
        
        # Make sure material uses blend mode
        mat.blend_method = 'BLEND'
        
        # Animate the transparency
        principled.inputs["Alpha"].keyframe_insert("default_value", frame=start_frame)
        principled.inputs["Alpha"].default_value = end_alpha
        principled.inputs["Alpha"].keyframe_insert("default_value", frame=start_frame + duration)
    
    return True


# === FILE FINDING FUNCTIONS ===
def find_file(filename):
    """Try to find a file in multiple common locations."""
    print(f"ğŸ” Searching for file: {filename}")
    
    for base_dir in POSSIBLE_LOCATIONS:
        if not os.path.exists(base_dir):
            print(f"  Directory doesn't exist: {base_dir}")
            continue
            
        # Try exact path
        file_path = os.path.join(base_dir, filename)
        if os.path.isfile(file_path):
            print(f"âœ… Found file at: {file_path}")
            return file_path
            
        # Try case-insensitive search in this directory
        print(f"  Searching directory: {base_dir}")
        try:
            for file in os.listdir(base_dir):
                if file.lower() == filename.lower():
                    found_path = os.path.join(base_dir, file)
                    print(f"âœ… Found file (case-insensitive) at: {found_path}")
                    return found_path
        except:
            print(f"  Error accessing directory: {base_dir}")
    
    print(f"âŒ Could not find file: {filename} in any location")
    return None


def import_glb(filepath, object_name):
    """Import a GLB and return the object."""
    if not os.path.isfile(filepath):
        raise FileNotFoundError(f"âŒ File not found: {filepath}")
    
    print(f"ğŸ“¦ Importing: {filepath}")
    
    # Remember objects before import
    before = set(bpy.data.objects)
    
    # Import the GLB file
    bpy.ops.import_scene.gltf(filepath=filepath)
    
    # Find new objects
    after = set(bpy.data.objects) - before
    imported_objs = [obj for obj in after if obj.type == 'MESH']
    
    if not imported_objs:
        print(f"âš ï¸ No meshes found in {filepath}")
        return None
        
    # Join objects if multiple were imported
    if len(imported_objs) > 1:
        bpy.ops.object.select_all(action='DESELECT')
        for obj in imported_objs:
            obj.select_set(True)
        bpy.context.view_layer.objects.active = imported_objs[0]
        bpy.ops.object.join()
        result = bpy.context.view_layer.objects.active
    else:
        result = imported_objs[0]
        
    # Rename the result
    result.name = object_name
    return result


def scale_object(obj, factor):
    """Scale an object uniformly."""
    if obj:
        obj.scale = (factor, factor, factor)


def reset_frame(frame=START_FRAME):
    """Reset timeline to specified frame."""
    bpy.context.scene.frame_set(frame)


def animate_handle(bag_object, start_frame, duration, rotation_amount, rotation_axis):
    """Animate the bag handle rotating back and forth."""
    if not bag_object:
        return
    
    original_mode = bag_object.rotation_mode
    bag_object.rotation_mode = 'XYZ'

    bag_object.rotation_euler = (0,0,0)
    bag_object.keyframe_insert("rotation_euler", frame=start_frame)

    bag_object.rotation_euler = rotation_axis * rotation_amount
    bag_object.keyframe_insert("rotation_euler", frame=start_frame + duration / 2)

    bag_object.rotation_euler = rotation_axis * -rotation_amount
    bag_object.keyframe_insert("rotation_euler", frame=start_frame + duration)

    bag_object.rotation_euler = (0,0,0)
    bag_object.keyframe_insert("rotation_euler", frame=start_frame + duration + (duration/2))

    bag_object.rotation_mode = original_mode
    print(f"ğŸ¬ Animated bag handle rotation")


def get_mesh_center(obj):
    """Return world-space center of object's bounding box."""
    local_bbox = [mathutils.Vector(v) for v in obj.bound_box]
    world_bbox = [obj.matrix_world @ v for v in local_bbox]
    return sum(world_bbox, mathutils.Vector()) / 8


def recenter_origin(obj):
    """Move origin of object to its bounding box center (world space)."""
    if not obj:
        return
    center = get_mesh_center(obj)

    # Shift mesh data so bounding box center becomes the origin
    mw = obj.matrix_world.copy()
    obj.matrix_world = mathutils.Matrix.Translation(center) @ mw

    # Reset origin to geometry center
    bpy.context.view_layer.objects.active = obj
    bpy.ops.object.origin_set(type='ORIGIN_GEOMETRY', center='BOUNDS')
    print(f"ğŸ¯ Re-centered origin for {obj.name}")


# === MAIN SCRIPT ===
# First find the bag file
bag_path = find_file(BAG_FILE)
if not bag_path:
    raise FileNotFoundError(f"Cannot find the bag file: {BAG_FILE}")

# Get the base directory from the bag file location
BASE_DIR = os.path.dirname(bag_path)
print(f"ğŸ“‚ Using base directory: {BASE_DIR}")

# Import the bag
bag = import_glb(bag_path, "Bag")
if not bag:
    raise Exception(f"âŒ Failed to import '{BAG_FILE}'.")

# Scale bag and animate handle
scale_object(bag, BAG_SCALE)  
animate_handle(bag, START_FRAME, DURATION, HANDLE_ROTATION_AMOUNT, HANDLE_ROTATION_AXIS)
bag_center = get_mesh_center(bag)

# === IMPORT ALL ITEMS FIRST ===
items = {}
for label, (filename, scale_factor, target_offset) in ITEM_FILES.items():
    try:
        # Try to find the item file
        item_path = find_file(filename)
        if not item_path:
            print(f"âŒ Skipping {label}: File not found")
            continue
            
        # Import the item
        item = import_glb(item_path, label)
        if not item:
            print(f"âŒ Skipping {label}: Import failed")
            continue
            
        # Special handling for AirPods
        if label == "AirPods":
            # Apply existing scales
            bpy.context.view_layer.objects.active = item
            bpy.ops.object.transform_apply(location=False, rotation=False, scale=True)
            recenter_origin(item)
            
            # Apply larger scale for AirPods
            scale_factor = scale_factor * 3
            
        # Scale the item
        scale_object(item, scale_factor)
        items[label] = {
            "object": item,
            "target_offset": target_offset
        }
            
    except Exception as e:
        print(f"âŒ Error processing {label}: {e}")

# === SPECIAL HANDLING FOR ITEMS ===
# Special handling for AirPods
if "AirPods" in items:
    # Create an empty at a known position
    bpy.ops.object.empty_add(type='PLAIN_AXES', location=(bag_center.x - 1.0, bag_center.y - 0.5, bag_center.z + 2.0))
    airpods_control = bpy.context.object
    airpods_control.name = "AirPodsControl"
    
    # Parent the AirPods to this empty
    airpods_obj = items["AirPods"]["object"]
    airpods_obj.parent = airpods_control
    
    # Reset the AirPods local position to origin
    airpods_obj.location = (0, 0, 0)
    
    # KEEP YOUR SUCCESSFUL ROTATION (what was working previously)
    airpods_obj.rotation_mode = 'XYZ'
    airpods_obj.rotation_euler = (math.radians(270), 0, math.radians(90))
    
    # Now we'll animate the empty instead of the AirPods directly
    items["AirPods"]["control"] = airpods_control
    
    print(f"ğŸ§ Applied rotation to AirPods: (270Â° X, 90Â° Z)")

# Special handling for PhoneCase - rotate 180 degrees on XY plane
if "PhoneCase" in items:
    phone_case_obj = items["PhoneCase"]["object"]
    phone_case_obj.rotation_mode = 'XYZ'
    # Rotate 180 degrees around Z-axis (this is rotation on XY plane)
    phone_case_obj.rotation_euler = (0, 0, math.radians(180))
    print(f"ğŸ“± Rotated PhoneCase 180Â° on XY plane (around Z axis)")

# === ANIMATE ITEMS ===
current_frame = START_FRAME

# Process items in this specific order
item_order = ["Pouch", "CardHolder", "PhoneCase", "AirPods"]

# Define starting positions relative to bag center
START_POSITIONS = {
    "Pouch":      mathutils.Vector(( 0.8,  0.7, 1.5)),
    "CardHolder": mathutils.Vector(( 0.0,  0.5, 1.0)),
    "PhoneCase":  mathutils.Vector((-0.8, -0.1, 0.8)),
    "AirPods":    mathutils.Vector((-0.8,  0.8, 1.8))  # Keep the starting position the same
}

last_item_end_frame = 0  # Track when the last item lands

for label in item_order:
    if label not in items:
        continue
    
    item_data = items[label]
    item_obj = item_data["object"]
    target_offset = item_data["target_offset"]
    
    try:
        # Determine which object to animate (AirPods uses control empty)
        if "control" in item_data:
            anim_obj = item_data["control"]
        else:
            anim_obj = item_obj
        
        # Get start position
        start_loc = bag_center + START_POSITIONS[label]
        
        # End location - using the configured target_offset
        end_loc = bag_center + target_offset
        if label == "CardHolder":
            end_loc += ADDITIONAL_CARD_HOLDER_OFFSET
            
        # Special custom end location for AirPods if needed
        if label == "AirPods":
            print(f"ğŸ§ AirPods will end at position: {end_loc}")

        # Midpoint arc - higher arc for AirPods
        if label == "AirPods":
            mid_loc = (start_loc + end_loc) / 2 + mathutils.Vector((0, 0, 1.0))
        else:
            mid_loc = (start_loc + end_loc) / 2 + mathutils.Vector((0, 0, 0.4))

        # Animate
        anim_obj.location = start_loc
        anim_obj.keyframe_insert(data_path="location", frame=current_frame)

        anim_obj.location = mid_loc
        anim_obj.keyframe_insert(data_path="location", frame=current_frame + DURATION / 2)

        anim_obj.location = end_loc
        anim_obj.keyframe_insert(data_path="location", frame=current_frame + DURATION)
        
        # Keep track of when the last item lands
        item_end_frame = current_frame + DURATION
        if item_end_frame > last_item_end_frame:
            last_item_end_frame = item_end_frame
        
        print(f"ğŸ¬ Animated {label} from {start_loc} to {end_loc}")
            
        current_frame += GAP
            
    except Exception as e:
        print(f"âŒ Error animating {label}: {e}")

# === ANIMATE BAG TRANSPARENCY ===
# Start transparency animation after the last item lands inside
transparency_start_frame = last_item_end_frame + 10  # Add a small delay
transparency_duration = 20  # How long it takes to fade

# Animate the bag transparency (80% transparent = 0.2 alpha)
animate_bag_transparency(bag, transparency_start_frame, transparency_duration, 1.0, 0.2)
print(f"ğŸ” Animated bag to 80% transparency starting at frame {transparency_start_frame}")

# === FINALIZE SCENE ===
# Make sure timeline extends past the transparency animation
bpy.context.scene.frame_end = transparency_start_frame + transparency_duration + 20
reset_frame()

print(f"""
âœ… Animation setup complete with adjusted positions:
   â€¢ AirPods moved further left to avoid intersection with card holder
   â€¢ Card holder moved slightly more right
   â€¢ All items now properly distributed inside bag without overlapping
   â€¢ Phone case rotated 180Â° on XY plane
   â€¢ AirPods rotation maintained at (270Â° X, 90Â° Z)
   â€¢ Bag becomes 80% transparent at frame {transparency_start_frame}

â–¶ï¸ Press Alt+A to play animation
""")
